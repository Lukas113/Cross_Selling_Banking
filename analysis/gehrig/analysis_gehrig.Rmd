---
output:
  html_document: default
  pdf_document: default
---

```{r echo = FALSE}
library(tidyverse)
library(RPostgreSQL)
library(zoo)
library(hrbrthemes)
library(lubridate)
library(ggpubr)
library(viridis)
source('../helpers/transformation.R')
```

```{r child = '../header.Rmd'}
```

### Datenanalyse mit Fokus auf "trans"

#### Erste Erkentnisse
Als erstes versuchte ich, einen Überblick über die aktuellen Daten zu erhalten, sowie alfällige Unregelmässigkeiten oder andere Auffälligkeiten aufzudecken. Folgende Punkte sind aufgefallen:

- Auffälligkeit: Identische "disp_id" und "client_id" bis "client_id" 8777 (Zeile 4987)

&rarr; n zu 1 Verbindung von "client" zu "account", was nicht exakt der Beschreibung der Daten entspricht. Da wird von einer m zu n Verbindung gesprochen, wonach ich vorerst die annahm, dass es sich bei "disp" um eine Transforationstabelle handelt. Jedoch, wenn die disp_id aufsteigend angeordnet sind, sind die client_ids streng monoton wachsend sowie die account_ids monoton wachsend, was auf eine n zu 1 Beziehung zwischen client zu account schliesst. Ist dies eine Business-Rule, könnte die "disp" Tabelle zur "client" Tabelle beigefügt werden. Aus technischer Sicht ist dies jedoch unproblematisch.

- Transdaten und IDs in "trans" 

&rarr; Die trans_ids sind nicht in chronologischer Reihenfolge aufgelistet, was man von einer Datenbank erwarten würde. Die IDs sind nach den account_ids erstellt worden, was nicht einer natürlichen Erzeugung der ids entspricht. Auch innerhalb der account_ids folgen die tans_ids nicht dem chronologischen Zeitverlauf, was eine genaue Sortierung nach den IDs verunmöglicht.
Zusätzlich sind die einzelnen Transaktionen nicht mit einem timestamp versehen, sondern lediglich mit einem Datum. Die Kombination von vermeintlich willkürlich gesetzten trans_ids und ungenauen Zeitangaben der Transaktionen erschwert die Analyse signifikant, da die Transaktionen mit diesen Angaben nie genau sortiert werden können.

Da die Datensätze relativ klein sind, erschien es mir sinnvoll, die Tables als R-Objekte lokal abzuspeichern, um diese danach lokal zu bearbeiten.
```{r echo = FALSE}
load(file = '../objects/account.rda')
load(file = '../objects/card.rda')
load(file = '../objects/client.rda')
load(file = '../objects/disp.rda')
load(file = '../objects/district.rda')
load(file = '../objects/loan.rda')
load(file = '../objects/orders.rda')
load(file = '../objects/trans.rda')
```

```{r echo = TRUE}
lowest_trans_date <- as.Date('1993-01-01')
lowest_year <- 1993
highest_trans_date <- as.Date('1998-12-31')
highest_year <- 1998

beginning_date <- function(year){
  return(as.Date(paste0(year, '-01-01')))
}

ending_date <- function(year){
  return(as.Date(paste0(year, '-12-31')))
}
```

#### Analyse fehlende Werte "trans"

In "trans" sind einige Werte in `k_symbol`, `bank`, `account` und `operation`: 'NA', ' '(leertaste), oder '0'. In diesem Abschnitt untersuche ich alle Vorkominisse dieser Unregelmässigkeiten, welche nicht in der Beschreibung erwähnt wurden, um die Daten besser zu verstehen und eventuell Unstimmigkeiten aufzudecken. Folgende Kombinationen von den erwähnten Werten in den Attributen sind aufgefallen:

- x_1 = `k_symbol`(' '), `bank`('NA'), `account`('0'), `operation`('VYBER'): Barkredit (n=616)
- x_2 = `k_symbol`(' '), `operation`('PREVOD NA UCET'): Überweisung an eine andere Bank (n=52817)

- x_3 = `k_symbol`('NA'), `bank`('NA'), `account`('NA'), `operation`('VKLAD'): Geldeinzahlung des Kunden an die Bank (n=156743)
- x_4 = `k_symbol`('NA'), `bank`('NA'), `account`('NA'), `operation`('VYBER'): Barkredit der Bank an den Kunden (n=263664)
- x_5 = `k_symbol`('NA'), `bank`('NA'), `account`('0'), `operation`('VYBER KARTOU'): Geldauszahlung Kreditkarte (n=8036)

- x_6 = `k_symbol`('NA'), `operation`('PREVOD NA UCET'): Überweisung an eine andere Bank (n=8155)
- x_7 = `k_symbol`('NA'), `operation`('PREVOD Z UCTU'): Überweisung von einer anderen Bank (n=34888)

- x_8 = `k_symbol`('UROK'), `bank`('NA'), `account`('NA'), `operation`('NA'): Zinsgutschrift der Bank an den Kunden (n=183114)
- x_9 = `k_symbol`('SLUZBY'), `bank`('NA'), `account`('NA'), `operation`('VYBER'): Barkredit für das bezahlen einer Rechnung (n=155832)
- x_10 = `k_symbol`('SANKC. UROK'), `bank`('NA'), `account`('NA'), `operation`('VYBER'): Negativzinsen, Gutschrift für die Bank (n=1577)
- x_11 = `k_symbol`('UVER'), `bank`('NA'), `account`('NA'), `operation`('PREVOD NA UCET'): Geldüberweisung an eine UNBEKANNTE Bank (n=1)
- x_12 = `k_symbol`('SIPO'), `bank`('NA'), `account`('0'), `operation`('VYBER'): Barkredit für Haushalt (n=2811)
- x_13 = `k_symbol`('POJISTNE'), `bank`('NA'), `account`('0'), `operation`('VYBER'): Barkredit für Versicherungsrechnung (n=23)


```{r echo = TRUE}
analyze_na <- function(frame){
  k_whitespace <- trans %>% dplyr::filter(k_symbol == ' ')
  x_1 <- k_whitespace %>% dplyr::filter(is.na(bank) & account == 0) %>% dplyr::count()
  x_2 <- k_whitespace %>% dplyr::filter(operation == 'PREVOD NA UCET') %>% dplyr::count()
  
  k_na <- trans %>% dplyr::filter(is.na(k_symbol))
  k_bank_na <- k_na %>% dplyr::filter(is.na(bank))
  x_3 <- k_bank_na %>% dplyr::filter(is.na(account) & operation == 'VKLAD') %>% dplyr::count()
  x_4 <- k_bank_na %>% dplyr::filter(is.na(account) & operation == 'VYBER') %>% dplyr::count()
  x_5 <- k_bank_na %>% dplyr::filter(account == 0 & operation == 'VYBER KARTOU') %>% dplyr::count()
  
  x_6 <- k_na %>% dplyr::filter(operation == 'PREVOD NA UCET') %>% dplyr::count()
  x_7 <- k_na %>% dplyr::filter(operation == 'PREVOD Z UCTU') %>% dplyr::count()
  
  bank_na <- trans %>% dplyr::filter(is.na(bank))
  bank_account_na <- bank_na %>% dplyr::filter(is.na(account))
  x_8 <- bank_account_na %>% dplyr::filter(k_symbol == 'UROK' & is.na(operation)) %>% dplyr::count()
  x_9 <- bank_account_na %>% dplyr::filter(k_symbol == 'SLUZBY' & operation == 'VYBER') %>% dplyr::count()
  x_10 <- bank_account_na %>% dplyr::filter(k_symbol == 'SANKC. UROK' & operation == 'VYBER') %>% dplyr::count()
  x_11 <- bank_account_na %>% dplyr::filter(k_symbol == 'UVER' & operation == 'PREVOD NA UCET') %>% dplyr::count()
  x_12 <- bank_na %>% dplyr::filter(k_symbol == 'SIPO' & account == 0 & operation == 'VYBER') %>% dplyr::count()
  x_13 <- bank_na %>% dplyr::filter(k_symbol == 'POJISTNE' & account == 0 & operation == 'VYBER') %>% dplyr::count()
  
  print(paste('x_1:', x_1$n))
  print(paste('x_2:', x_2$n))
  print(paste('x_3:', x_3$n))
  print(paste('x_4:', x_4$n))
  print(paste('x_5:', x_5$n))
  print(paste('x_6:', x_6$n))
  print(paste('x_7:', x_7$n))
  print(paste('x_8:', x_8$n))
  print(paste('x_9:', x_9$n))
  print(paste('x_10:', x_10$n))
  print(paste('x_11:', x_11$n))
  print(paste('x_12:', x_12$n))
  print(paste('x_13:', x_13$n))
  
}

analyze_na(trans)
```
Die gefundenen Kombinationen scheinen vorerst keine besondere Bedeutung zu haben.

#### Trans `type`
In diesem Abschnitt wird der `type` der Transaktionstabelle untersucht, da während der Vermögensanalyse grosse unstimmigkeiten bezüglich der Vermögensanalyse aufgefallen sind.
Gemäss der Beschreibung sind folgende Werte definiert:
- 'PRIJEM' stands for credit 
- 'VYDAJ' stands for withdrawal
Jedoch ist in der Datenbank ein dritter `type` 'VYBER' (n=16666) vorhanden. Dieser wird für eine vereinfachte Analyse auf 'VYDAJ' umgewandelt, was bedenkenlos gemacht werden kann, da 'VYBER' in `type` nicht definiert ist und die geschätzten Vermögen aufgund der Konto Ein- und Ausgänge dem Kontostand `balance` des letzten Tages ziemlich Nahe kommen (siehe 'Delta Estimated Balance Comparison').
```{r echo = TRUE}
trans_type_vyber <- function(trans_frame){
  ggplot2::ggplot(data = trans_frame) + 
    ggplot2::geom_bar(mapping = aes(x = type, fill = type))
}

trans_type_vyber(trans)
```

#### Data-Frames Anpassen
Folgende Anpassungen werden vorgenommen:
- Bei Zweideutigkeiten von von Variabelbenennungen wird der jeweilige Tabellenname kombiniert, um Komplikationen bei Joins zu vermeiden. Bsp: `date` von "trans" wird zu `trans_date`.
- Koorektur von Fehlerhaften Werten, Bsp: `trans_type` 'VYBER' wird gemäss obiger Erkentniss zu 'VYDAJ'.
```{r echo = TRUE}
trans_altered <- alter_trans(trans)
account_altered <- alter_account(account)
disp_altered <- alter_disp(disp)
card_altered <- alter_card(card)
loan_altered <- alter_loan(loan)
orders_altered <- alter_orders(orders)
```


#### Account & Loan

Wir haben die Hypothese, dass jeder "account" maximal eine "loan" hat.
Unsere Hypothese hat sich bestätigt, Beweis:
```{r echo = TRUE}
account_loan_check <- function(account_frame, loan_frame){
  account_loan <- dplyr::inner_join(account_frame, loan_frame, by = 'account_id') %>%
    dplyr::count(account_id) %>%
    dplyr::select(n)
  return(base::summary.data.frame(account_loan))
}

account_loan_check(account_altered, loan_altered)
```

#### Orders ohne Transaktionen

Während der Datenanalyse ist aufgefallen, dass nicht alle "orders" in "trans" abgebildet sind. Aus diesem Grund erfolgt eine Validierung, auf welchen "orders" überhaupt Transaktionen ausgeführt wurden. Geprüft wurde auf `account_id` und `account_to`, da in "trans" nicht die Verbindung zu "orders" direkt gegeben ist. Zusätzlich ist bei "orders" auch kein Anfangs- und Enddatum angegeben, was eine Validierung erschwert. Wenn eine Transaktion von deinem "account" zum in "orders" definierten `account_to` vorhanden ist, sowie der `amount` von "trans" und "orders" übereinstimmt, wurde die Order mit hoher Wahrscheinlichkeit ausgeführt. Somit werden hier diejenigen Transaktionen herausgefiltert, bei denen 100% nie eine Transaktion ausgeführt wurde.
```{r echo = TRUE, fig.width = 10}
validate_orders <- function(orders_frame, account_frame, trans_frame, combined = FALSE){
  #' @description filters all orders where never a payment is registered in trans (based on account_to matching)
  
  orders_in_trans <- orders_frame %>%
    dplyr::inner_join(account_altered, by = 'account_id') %>%
    dplyr::inner_join(trans_frame, by = c('account_id', 'account_to' = 'account', 'amount' = 'trans_amount')) %>%
    dplyr::select(account_id, account_to, amount, orders_k_symbol) %>%
    dplyr::distinct() %>%
    dplyr::mutate(shown_in_trans = TRUE)
  
  orders_not_in_trans <- orders_in_trans %>%
    dplyr::rename(account_id_left = account_id, account_to_left = account_to, amount_left = amount, orders_k_symbol_left = orders_k_symbol) %>%
    dplyr::right_join(orders_frame, by = c('account_id_left' = 'account_id', 'account_to_left' = 'account_to', 'orders_k_symbol_left' = 'orders_k_symbol')) %>%
    dplyr::filter(is.na(amount_left)) %>%
    dplyr::select(-amount_left) %>%
    dplyr::rename(account_id = account_id_left, account_to = account_to_left, orders_k_symbol = orders_k_symbol_left) %>%
    dplyr::mutate(shown_in_trans = FALSE)
  
  if(combined){
    orders_combined <- orders_not_in_trans %>%
      dplyr::select(account_id, account_to, amount, orders_k_symbol, shown_in_trans) %>%
      dplyr::bind_rows(orders_in_trans)
    return(orders_combined)
  }else{
    return(orders_not_in_trans)
  }
}

visualize_orders_validation <- function(orders_frame, account_frame, trans_frame){
  orders_labeled <- validate_orders(orders_frame, account_frame, trans_frame, TRUE)
  
  orders_labeled_plot <- ggplot2::ggplot(data = orders_labeled, aes(x = shown_in_trans, fill = orders_k_symbol)) + 
    ggplot2::geom_bar() +
    ggplot2::ggtitle('Orders NOT IN & IN Trans')
  
  orders_not_in_trans <- validate_orders(orders_frame, account_frame, trans_frame)
  orders_not_in_trans_plot <- ggplot2::ggplot(data = orders_not_in_trans, aes(x = orders_k_symbol, fill = orders_k_symbol)) +
    ggplot2::geom_bar() +
    ggplot2::ggtitle('Distribution of orders_k_symbol of Orders NOT IN Trans')
  
  print(orders_labeled_plot)
  print(orders_not_in_trans_plot)
}

visualize_orders_validation(orders_altered, account_altered, trans_altered)
```
Die meisten "orders" sind in "trans" mindestens einmal ausgeführt worden. Jedoch wurde bei fast 400 "orders" niemals eine Transaktion ausgeführt. Ein Teil davon ist erklärbar, da es möglich ist, dass einige "orders" erst kürzlich erfasst wurden, und somit nie eine Zahlung ausgeführt werden konnte. Es ist jedoch überraschend auffällig, dass keine einzige `k_symbol` 'LEASING' ausgeführt wurde, obwohl in "orders" immer der `account_to`, `bank` und `amount` angegeben ist.

Es wurde bereits erwähnt, dass der Verlauf der IDs diverser Tabellen nicht natürlich dem Zeitverlauf entsprechen. Daraus folgt, dass die DB künstlich im Nachhinein aufgesetzt wurde. Wir nehmen an, dass das Fehlen sämtlicher Orders 'LEASING' ein Fehler in der DB ist, das bei der Erstellung nicht genügend berücksichtigt wurde.


#### Vermögen pro Account
Um eine Übersicht über die Vermögensverhältnisse der Bankkunden zu erhalten, wird hier das Vermögen der Kunden am 31.12.1998 sowie einiger statistischer Kennwerte ausgewiesen. Dies dient einerseits der Validierung und ist zugleich ein Vergleichswert späterer Analysen.
Um die Vermögensverteilung adequat auszuweisen, wird auf eine multivariate Darstellung verzichtet, und eine Kernel-Density-Estimation (KDE) über die Verteilung gezogen. Dies wiederspiegelt nicht genau die wahren Dichteverhältnisse der Verteilung. Sie hilft jedoch, schnell und einfach einen Überblick über die Vermögensverteilung zu erhalten.
Es ist wichtig zu erwähnen, dass es sich hierbei um geschätzte Endvermögen handelt, d.h. es können kleinere Abweichungen vom realen Endvermögen entstehen, da die in "Erste Erkentnisse" erwähnten Sortierungsprobleme hier eine Rolle spielen. Die Abweichungen sollten sich jedoch im Rahmen halten, wie in "Delta Estimated Balance Comparsion" ersichtlich ist.
```{r echo = TRUE}
balance_account <- function(trans_frame, min_date = lowest_trans_date, max_date = highest_trans_date){
  min_date <- as.Date(min_date)
  max_date <- as.Date(max_date)
  account_balance <- trans_frame %>% 
    dplyr::filter(trans_date >= min_date & trans_date <= max_date) %>%
    dplyr::group_by(account_id) %>%
    dplyr::filter(trans_date == max(trans_date)) %>%
    dplyr::filter(trans_id == max(trans_id)) %>%
    dplyr::arrange(account_id)
  return(account_balance)
}

balance_distribution <- function(trans_frame, min_date = lowest_trans_date, max_date = highest_trans_date, binwidth = 2000){
  balances <- balance_account(trans_frame, min_date, max_date)
  ggplot2::ggplot(data = balances, aes(balance)) + 
  ggplot2::geom_density(aes(y =..density..), fill = 'red', alpha = 0.85) +
  ggplot2::scale_x_continuous(labels = scales::comma) +
  ggplot2::labs(title = paste0('Account Balance Distribution ', max_date), x = 'balance', y = 'density')
}

b_acc <- balance_account(trans_altered)
base::summary(b_acc$balance)

balance_dist <- balance_distribution(trans_altered)
balance_dist
```
Eine Minderheit der Accounts hat ein negatives Saldo auszuweisen. Dies ist am klaren Anstieg der Dichtekurve der Vermögensverteilung nach dem Nullpunkt ersichtlich. Der Modus befindet sich etwa bei 25'000 Kronen, welcher sich unter dem Median (38495) und Mittelwert (43809) befindet, da die Kurve klar rechtsschief ist. Die meisten Accounts haben zwischen 10'000 und 100'000 Kronen Vermögen auszuweisen.
Da es nach oben und unten keine wirklichen Ausreisser hat, schliesse ich daraus, dass es wahrscheinlich entweder ein nicht zufälliger selektierter Teilausschnitt einer Datenbank ist, oder die Daten komplett random generiert wurden.

#### Vermögenverhältnisse der Bank über mehrere Jahre
Als nächstes wird untersucht, ob die Bank über die letzten Jahre eine Veränderung bezüglich der Vermögensverteilung der Bankkunden erlebt hat. Hierbei ist somit nicht die absolute Vermögensveränderung der Bank von interesse, sondern, ob sich der Kundenstamm bezüglich Vermögen in den letzten Jahren verändert hat. Ausgewiesen wird hierbei das geschätzte Vermögen des Kundenstamms auf Jahresende.
```{r echo = TRUE}
for (year in lowest_year:highest_year) {
  b_dist <- balance_distribution(trans_altered, max_date = ending_date(year))
  print(b_dist)
}
```
Es ist zu erkennen, dass die Bank über den observierten Zeitraum von 6 Jahren immer eine ähnliche Vermögensverteilung der Kunden aufweist. Somit ist erwiesen, dass sich der Kundenstamm über die letzten Jahre bezüglich Vermögen nicht signifikant verändert hat.

#### Produkteselektion Cross-Selling
Gemäss unserem Auftrag müssen wir mit bestehenden Produkten einen Mehrwert an bestehende Kunden generieren, also Cross-Selling betreiben. Gemäss dem Entity Relationship Model (ERD) und der darauf basierenden Datenanalyse bezüglich dem Kundenanteil, die dieses Produkt bereits haben, haben wir 2 potentielle Produkte evaluiert:
- Loan
- Kreditkarten

Beide haben gemäss der Datenanalyse von Simon und Lukas (Märki) einen tiefen Durchdringungsgrad im bestehenden Kundenstamm, und sind somit beide lukrativ.
Wir fokusieren unsere weitere Arbeit auf Kreditkarten, da wir der Auffassung sind, dass diese von mehr Kunden benötigt wird. Dabei steckt folgende Überlegung:

Wir halten es nicht für sinnvoll, jemandem eine Loan zu verkaufen, da dieses Bedürfnis eher vom Kunden her selbst kommt. Von Kreditkarten jedoch kann beinahe jeder Kunde profitieren, da diese in einigen Bereichen das Leben vereinfacht und keine wirklichen Nachteile mit sich zieht. Daher fokussiert sich unsere künftigen Analysen auf Kreditkarten.

#### Card Ownership
Uns interessiert, wie bisher die Kreditkartenvergabe stattgefunden hat. Die Kunden können in die Typen 'OWNER' und 'DISPONENT' eingeteilt werden. Zusätzlich ist die Verteilung der verschiedenen Typen der Karte von Interesse.
```{r echo = TRUE}
card_ownership <- function(card_frame, disp_frame){
  ownership_frame <- card_frame %>%
    dplyr::inner_join(disp_frame, by = 'disp_id')
  
  ggplot2::ggplot(data = ownership_frame) + 
    ggplot2::geom_bar(mapping = aes(x = card_type, fill = disp_type))
}

card_ownership(card_frame = card_altered, disp_frame = disp_altered)
```
Das Ergebnis überrascht. Hier ist ersichtlich, dass nur 'OWNER' eines Accounts eine Kreditkarte besitzen. Dies ist so nicht aus der Beschreibung her ersichtlich.
Auch die Verteilung der Karten unterscheidet sich stark. Der `card_type` 'classic' ist relativ gesehen stark übervertreten. Da 'gold' und 'junior' eine ziemlich kleine Dichte aufweisen, müssen wir bei der Wahl des Timeframes vorsichtig vorgehen, um noch genügend Kunden mit 'gold' und 'junior' in der Analyse mit dabei zu haben.

Zusätzlich kann sich die Analyse der verschiecenen Kartentypen auf die "accounts" beschränkt werden, da bewiesen ist, dass die bisher die Karten nur an 'OWNER' vergeben wurden. Ansonsten wäre eine genauere Kundenanalyse bezüglich Karten zusätlich erschwert, da von "client" zu "account" eine n zu 1 Beziehung besteht.

#### Account Vermögen und Vermögensveränderungen
Einerseits ist es interessant, wie sich die Kartentypen `card_type` bezüglich Vermögen und Vermögensversänderung unterscheiden. Andererseits müssen wir auch untersuchen, wie sich die Kartenbesitzer von den nicht-Kartenbesitzer unterscheiden. Folglich werden die Daten entsprechend vorbereitet. Eine Beschreibung der Analyse ist bei den Plots angesiedelt.

Erstellung des Daten-Frames zur monatlichen, jährlichen und absoluten Vermögensveränderung.
```{r echo = TRUE ,warning = FALSE}
balance_delta <- function(balances){
  return(c(NA, diff(balances)))
}

balance_delta_initial <- function(balances){
  return(c(balances[1], diff(balances)))
}

balance_growth_end_of_years <- function(trans_frame, with_initial_balance = FALSE){
  #' @description returns the yearly balance at end of year of each customer
  
  bal_grw <- trans_frame %>%
    dplyr::mutate(year = format(trans_date, '%Y')) %>%
    dplyr::group_by(account_id, year) %>%
    dplyr::filter(trans_date == max(trans_date)) %>%
    dplyr::filter(trans_id == max(trans_id)) %>%
    dplyr::arrange(account_id, trans_date)
   
  if (with_initial_balance){
    bal_grw$balance_delta <- as.numeric(unlist(by(bal_grw$balance, bal_grw$account_id, balance_delta_initial)))
  }else{
    bal_grw$balance_delta <- as.numeric(unlist(by(bal_grw$balance, bal_grw$account_id, balance_delta)))
  }
  return(bal_grw)
}

customer_balance_change_estimation <- function(trans_frame, without_initial_balance = FALSE, min_date = lowest_trans_date, max_date = highest_trans_date, join_data_frame = NA){
  #' @description returns the estimated income and expenses, total and monthly, from each customer. In addition, the already jointed data frame 'card', 'disp' & 'account' can be given in `join_data_frame` to get the account and card specific data at the time of the customer's receipt of their credit card.
  
  cust_bal_ch <- trans_frame
  
  if(without_initial_balance){#filters opening balance if one is interested just in the estimated income
    cust_bal_ch <- cust_bal_ch %>%
      dplyr::group_by(account_id) %>%
      dplyr::filter(trans_date != min(trans_date))
  }
  
  if(is.na(join_data_frame)){
    cust_bal_ch <- cust_bal_ch %>%
      dplyr::filter(trans_date >= min_date & trans_date <= max_date) %>%
      dplyr::group_by(account_id, trans_type) %>%
      dplyr::summarise(balance_change = sum(trans_amount))
  }else{
    cust_bal_ch <- cust_bal_ch %>%
      dplyr::inner_join(join_data_frame, by = 'account_id') %>%
      dplyr::group_by(account_id) %>%
      dplyr::filter(trans_date < issued) %>%
      dplyr::filter(trans_date >= min_date & trans_date <= max_date) %>%
      dplyr::group_by(account_id, trans_type, card_type) %>% #including card_type
      dplyr::summarise(balance_change = sum(trans_amount))
  }
  
  cust_bal_ch$balance_delta <- (as.numeric(unlist(by(cust_bal_ch$balance_change, cust_bal_ch$account_id, balance_delta)))*-1)
  
  cust_bal_ch <- trans_frame %>%
    dplyr::filter(trans_date >= min_date & trans_date <= max_date) %>%
    dplyr::group_by(account_id) %>%
    dplyr::summarise(duration_month = (zoo::as.yearmon(max(trans_date)) - zoo::as.yearmon(min(trans_date))) * 12 + 1) %>% #diff num of months
    dplyr::inner_join(cust_bal_ch, by = 'account_id') %>%
    dplyr::mutate(monthly_change = balance_change / duration_month) %>%
    dplyr::mutate(monthly_balance_delta_change = balance_delta / duration_month)
  
  return(cust_bal_ch)
}
```

```{r echo = TRUE, warning = FALSE}
card_balance_change_correlation <- function(trans_frame, account_frame, disp_frame, card_frame){
  #' @description gets the dataframe of the balance_change until the date the credit card is issued
  prep_frame <- card_frame %>%
    dplyr::inner_join(disp_frame, by = 'disp_id') %>%
    dplyr::inner_join(account_frame, by = 'account_id')
  
  return(customer_balance_change_estimation(trans_frame = trans_frame, join_data_frame = prep_frame))
}

plot_balance_change <- function(trans_frame, account_frame, disp_frame, card_frame){
  #' @description balance_plot controller
  df_cbcc <- card_balance_change_correlation(trans_frame, account_frame, disp_frame, card_frame)
  df_vydaj <- df_cbcc %>% dplyr::filter(trans_type == 'VYDAJ')
    
  flow_total <- ggplot2::ggplot(data = df_cbcc, aes(x = balance_change, group = card_type, fill = card_type)) +
    ggplot2::geom_density(adjust = 1.5, alpha = 0.4) +
    ggplot2::xlab('money') +
    ggplot2::ggtitle('Total Flow of Money until the Card is Issued') +
    hrbrthemes::theme_ipsum() +
    ggplot2::scale_x_continuous(labels = scales::comma) +
    ggplot2::facet_wrap(~ trans_type)
  
  flow_monthly <- ggplot2::ggplot(data = df_cbcc, aes(x = monthly_change, group = card_type, fill = card_type)) +
    ggplot2::geom_density(adjust = 1.5, alpha = 0.4) +
    ggplot2::xlab('money') +
    ggplot2::ggtitle('Monthly Average Flow of Money until the Card is Issued') +
    hrbrthemes::theme_ipsum() +
    ggplot2::scale_x_continuous(labels = scales::comma) +
    ggplot2::facet_wrap(~ trans_type)
  
  balance_delta_total <- ggplot2::ggplot(data = df_vydaj, aes(x = balance_delta, group = card_type, fill = card_type)) +
    ggplot2::geom_density(adjust = 1.5, alpha = 0.4) +
    ggplot2::xlab('money') +
    ggplot2::ggtitle('Total Balance when the Card is Issued') +
    hrbrthemes::theme_ipsum() +
    ggplot2::scale_x_continuous(labels = scales::comma)
  
  balance_delta_monthly <- ggplot2::ggplot(data = df_vydaj, aes(x = monthly_balance_delta_change, group = card_type, fill = card_type)) +
    ggplot2::geom_density(adjust = 1.5, alpha = 0.4) +
    ggplot2::xlab('money') +
    ggplot2::ggtitle('Monthly Average Balance Change until the Card is Issued') +
    hrbrthemes::theme_ipsum() +
    ggplot2::scale_x_continuous(labels = scales::comma)
  
  assign('flow_total', flow_total, envir = .GlobalEnv)
  assign('flow_monthly', flow_monthly, envir = .GlobalEnv)
  assign('balance_delta_total', balance_delta_total, envir = .GlobalEnv)
  assign('balance_delta_monthly', balance_delta_monthly, envir = .GlobalEnv)
  balance_delta_monthly_summary <- tapply(df_vydaj$monthly_balance_delta_change, df_vydaj$card_type, summary)
  assign('balance_delta_monthly_summary', balance_delta_monthly_summary, envir = .GlobalEnv)
}
plot_balance_change(trans_altered, account_altered, disp_altered, card_altered)
```

#### Genauigkeitsüberprüfung der Einkommens- und Vermögensschätzung

Bevor mit weiteren Analysen auf Stufe Kreditkarte fortgefahren wird, ist es sinnvoll, die geschätzten Vermögen und Vermögensveränderungen zu validieren. Dies stellt sicher, dass angenommen werden kann, dass die in "trans" enthaltenen Transaktionen korrekt sind und um den geschätzten Werte entsprechend Gewicht beizumessen.
Verglichen werden die Endwerte `balance` von den einzelnen "accounts" sowie der Addition aller Einnahmen `PRIJEM` und Subtraktion aller Ausgaben `VYDAJ`, welche in `balance_delta` ausgewiesen werden.
```{r echo = TRUE}
check_balance_change_estimation <- function(){
  estimation <- customer_balance_change_estimation(trans_frame = trans_altered)
  estimation <- estimation %>%
    dplyr::filter(trans_type == 'VYDAJ') %>%
    dplyr::select(account_id, balance_delta)
  
  balances <- balance_account(trans_altered)
  balances <- balances %>%
    dplyr::select(account_id, balance)
  
  comparison_frame <- estimation %>%
    dplyr::inner_join(balances, by = 'account_id') %>%
    dplyr::mutate(delta = abs(balance - balance_delta))
  
  #alter to eliminate outliers to get a better plot
  comparison_frame_altered <- comparison_frame %>%
    dplyr::filter(delta < 250)
  
  comparison_plot <- ggplot2::ggplot(comparison_frame_altered, aes(delta)) +
    ggplot2::geom_histogram(aes(y = ..count..), binwidth = 5, fill = "skyblue") +
    ggplot2::labs(title = 'Delta Estimated Balance Comparison')
  
  print(base::summary.data.frame(comparison_frame %>% dplyr::select(-account_id)))
  print(comparison_plot)
}

check_balance_change_estimation()
```
Die Abweichung des geschätzten Vermögens und der Geldflüsse ist relativ gesehen gering. Dies bestätigt die Korrektheit der in `amount` enthaltenen Transaktionswerte. Die meisten Abweichungen liegen zwischen den Werten 5.4 und 17.0. Die Maximaldifferenz liegt bei 1200.3. Die grösseren Abweichungen sind dadurch erklärbar, da es sich bei den abgefragten Vermögensendbeständen `balance` lediglich um Schätzwerte handelt, da die Transaktionen nicht sauber sortiert werden konnten. Die kleineren Abweichungen können dadurch erklärt werden, dass sich bei in `amount` um mathematisch korrekt gerunde Werte handelt. Die Summe all dieser Rundungsfehler kann bei mehreren Dutzend Transaktionen zu einer absoluten Abweichung im geschätzten Vermögen im zweistelligen Bereich führen.


#### Vermögensveränderung und Vermögen der Kreditkartenbesitzer

Wir haben die Annahme, dass sich das Vermögen und die Vermögensveränderung der Kreditkartenbesitzer der verschiedenen Kartentypen `card_type` 'classic', 'gold' und 'junior' voneinander unterscheiden. Aus diesem Grund wird das Vermögen und die Vermögensveränderung der Kreditkartenbesitzer verglichen. Der gewählte Zeitraum bezieht sich hierbei bei der Vermögensveränderung über den ganzen Zeitraum der verfügbaren Daten des Kunden bis zum Zeitpunkt des Kreditkartenerwerbs. Beim Vergleich der Vermögen wird die letzte `balance` zum Zeitpunkt des Kartenerwerbes berücksichtigt.

Diese Analyse hat den Zweck, um die Unterschiede zwischen den verschiedenen Kartentypen `card_type` aufzuzeigen, um Aussagen bezüglich Vermögen und Vermögensveränderungen auf potentielle Kunden bezüglich Kreditkarten machen zu können. Hierbei werden alle jemals erstellten Kreditkarten berücksichtigt.

**Total Flow of Money until the Card is Issued**
```{r echo = TRUE, warning = FALSE, fig.width = 10}
flow_total
```
Die Totalen Kontoeinzahlungen und Auszüge sind ziemlich ähnlich, was nicht überraschend ist, da wir gemäss Vermögensanalyse keine Ausreisser haben. Bei dieser Analyse ist ersichtlich, dass es grosse Unterschiede zwischen den gesamten Vermögenszu- und Abflüsse zeischen 'gold' und den beiden anderen Kartentypen gibt. Diese Verteilung ist jedoch mit Vorsicht zu geniessen, da es "accounts", die nicht schon über einen längeren Zeitraum bei der Bank sind, entsprechend benachteiligt.

**Monthly Average Flow of Money until the Card is Issued**
```{r echo = TRUE, warning = FALSE, fig.width = 10}
flow_monthly
```
Bei dieser Darstellung werden die Nachteile der *Total Flow of Money until the Card is Issued* Vermögensflüsse ausgehebelt, dass erst kürzlich beigetretene Bankkunden in der Analyse benachteiligt werden, da die Veränderungen auf den Durchschnitt pro Monat dargestellt werden. Es kann sogar sein, dass erst kürzlich der Bank beigetretene Kunden stärker gewichtet werden, da das Initial eingezahlte Vermögen tendenziell grösser sein kann, als die danach durchschnittlich ein- und ausbezahlten monatlichen Beträge.
Nichtsdestotrotz zeichnet sich ein ähnliches Bild der jeweiligen Kartentypen an, wie bei *Total Flow of Money until the Card is Issued*.

**Total Balance when the Card is Issued**
```{r echo = TRUE, warning = FALSE, fig.width = 10}
balance_delta_total
```
Hier zeigt es klare Unterschiede zwischen den jeweiligen Kartentypen bezüglich des Vermögens zum Zeitpunkt der Kreditkartenbeantragung. Vermögendere Kunden beziehen eher eine 'gold' Karte. Die 'classic' Kunden befinden sich im Mittelfeld. Am wenigsten Vermögen haben im Schnitt die 'junior' Kunden, wobei sich die 'junior' und 'classic' Kunden nicht so stark unterscheiden, wie die 'gold' Kunden zu den anderen Beiden.

**Monthly Average Balance Change until the Card is Issued**
```{r echo = TRUE, warning = FALSE, fig.width = 10}
balance_delta_monthly
balance_delta_monthly_summary
```
Hierbei wird die monatliche Vermögensveränderung, bevor die Karte beantragt wurde, berücksichtigt. Bei diesem Plot halten sich die Ausreisser in Grenzen, da bei jeder Kunde, der eine Kreditkarte beantragt hatte, mindestens 6 Monate Kunde war. Damit ist zwar sichergestellt, dass das Initial eingezahlte Vermögen hierbei einen reduzierteren Einfluss hat, trotzdem wird es stärker gewichtet, als bei Kunden, die bisher länger bei der Bank Kunden sind.
Es gibt klare Unterschiede bezüglich Mittelwert aller drei Kartentypen sowie vom Median von 'junior' zu den anderen beiden Typen. Somit lässt sich daraus schliessen, dass Kunden, welche eine höheren mittleren Vermögenszuwachs haben, eher für eine höher gestufte Karte geeignet ist in der Annahme, dass die bisher vergebenen Kreditkarten gut verteilt wurden.


#### Vermögen und Geldflüsse der Kunden, die 1998 eine Kreditkarte erworben hatten

Hier werden Kunden, die im Jahr 1998 eine Kreditkarte erworben haben mit Kunden Ende 1998 verglichen, um Unterschiede und Gemeinsamkeiten bezüglich des Vermögens und der Geldflüsse festzustellen.

```{r echo = TRUE}
get_balance_inf <- function(trans_frame){
  balances <- balance_account(trans_frame)
  inflow_outflow <- trans_frame %>%
    dplyr::group_by(account_id, trans_type) %>%
    dplyr::summarise(balance_change = sum(trans_amount))
  
  inflow_outflow$balance_delta <- (as.numeric(unlist(by(inflow_outflow$balance_change, inflow_outflow$account_id, balance_delta)))*-1)
  
   inflow_outflow <- inflow_outflow %>%
     dplyr::group_by(account_id) %>%
     dplyr::mutate(VYDAJ = balance_change, PRIJEM = dplyr::lag(balance_change)) %>%
     dplyr::select(account_id, VYDAJ, PRIJEM, balance_delta) %>%
     dplyr::filter(!is.na(PRIJEM)) %>%
     dplyr::inner_join(balances, by = 'account_id') %>%
     dplyr::select(account_id, account_date, VYDAJ, PRIJEM, balance_delta, balance, card_type, account_divisor_months)
  
  return(inflow_outflow)
}

card_purch_comp <- function(trans_frame, account_frame, disp_frame, cards_frame, start_date, ending_date){
  inc_offset_days <- (ending_date - start_date) + 1
  month_diff <- (zoo::as.yearmon(ending_date) - zoo::as.yearmon(start_date)) * 12 + 1
  
  account_cards <- account_frame %>%
    dplyr::inner_join(disp_frame, by = 'account_id') %>%
    dplyr::filter(disp_type == 'OWNER') %>%
    dplyr::left_join(cards_frame, by = 'disp_id') %>%
    dplyr::select(account_id, account_date, frequency, account_date, card_type, issued)
  
  #time frame (card-issued minus day_difference(start_date, ending_date)) until card-issued 
  accounts_with_cards <- account_cards %>%
    dplyr::filter(!is.na(card_type)) %>%
    dplyr::filter(issued >= start_date & issued <= ending_date) %>%
    dplyr::inner_join(trans_frame, by = 'account_id') %>%
    dplyr::group_by(account_id) %>%
    dplyr::filter(trans_date <= issued & trans_date > (issued - inc_offset_days)) %>%
    dplyr::mutate(account_divisor_months = min(((zoo::as.yearmon(issued) - zoo::as.yearmon(account_date)) * 12 + 1), month_diff))
  
  #time-frame start_date until end_date
  accounts_without_cards <- account_cards %>%
    dplyr::filter(is.na(card_type)) %>%
    dplyr::inner_join(trans_frame, by = 'account_id') %>%
    dplyr::group_by(account_id) %>%
    dplyr::filter(trans_date <= ending_date & trans_date >= start_date) %>%
    dplyr::select(-issued) %>%
    dplyr::mutate(account_divisor_months = min(((zoo::as.yearmon(ending_date) - zoo::as.yearmon(account_date)) * 12 + 1), month_diff))
  
  balance_inf_without_cards <- get_balance_inf(accounts_without_cards)
  balance_inf_with_cards <- get_balance_inf(accounts_with_cards)
  
  result_frame <- balance_inf_without_cards %>%
    dplyr::union(balance_inf_with_cards) %>%
    dplyr::mutate(monthly_VYDAJ = (VYDAJ / account_divisor_months), monthly_PRIJEM = (PRIJEM / account_divisor_months),
                  monthly_balance_delta = (balance_delta / account_divisor_months), 
                  avg_balance = balance - (monthly_balance_delta * (account_divisor_months / 2))) %>%
    dplyr::ungroup()
  
  result_frame$card_type[is.na(result_frame$card_type)] <- 'no_card'
  
  return(result_frame)
}

#card_purch_comp(trans_altered, account_altered, disp_altered, card_altered, beginning_date('1998'), ending_date('1998'))
```


```{r warning = FALSE, fig.width = 8}
plot_balance_cards_comp <- function(trans_frame, account_frame, disp_frame, cards_frame, start_date, ending_date, var_1, var_2, var_3, var_4, var_5, stat_inf){
  #' @description provides credit card specific plots in the global environment with the given var_<number> names & the according statistical information in the given var_<number>_summary variables.
  #' credit card holders with purchase in the specified period were considered as well as their information from the time of credit card purchase - length of the specified timeframe
  #' for non-credit card holders, the data is taken into account throughout the specified time interval
  #' - balance_total at the end of the timeframe
  #' - balance_average (begin_balance + end_balance) / 2 --- customers who weren't there from the beginning of the timeframe were filtered out.
  #' - balance_change monthly during the specified timeframe
  #' - flow_VYDAJ means monthly withdrawal of money in the specified timeframe
  #' - flow_PRIJEM means monthly inflow of money in the specified timeframe
  month_diff <- (zoo::as.yearmon(ending_date) - zoo::as.yearmon(start_date)) * 12 + 1
  prep_frame <- card_purch_comp(trans_frame, account_frame, disp_frame, cards_frame, start_date, ending_date)
  adjust <- 1
  alpha <- 0.4
  violin_width = 1.1
  
  balance_total <- ggplot2::ggplot(data = prep_frame, aes(x = card_type, y = balance, fill = card_type)) +
    ggplot2::geom_violin(width = violin_width) +
    ggplot2::geom_boxplot(width = 0.1, color = 'grey', alpha = 0.2) +
    viridis::scale_fill_viridis(discrete = TRUE) +
    hrbrthemes::theme_ipsum() +
    ggplot2::theme(legend.position = 'none', plot.title = element_text(size = 11)) +
    ggplot2::ggtitle(paste0('Total Balance ', ending_date)) +
    ggplot2::scale_y_continuous(labels = scales::comma)
  # balance_total <- ggplot2::ggplot(data = prep_frame, aes(x = balance, group = card_type, fill = card_type)) +
  #   ggplot2::geom_density(adjust = adjust, alpha = alpha) +
  #   ggplot2::xlab('money') +
  #   ggplot2::ggtitle(paste0('Total Balance ', ending_date)) +
  #   hrbrthemes::theme_ipsum() +
  #   ggplot2::scale_x_continuous(labels = scales::comma)
    
  #estimated avg balance (Opening balance + closing balance / 2) of the time frame
  prep_frame_altered <- prep_frame %>% dplyr::filter(account_divisor_months == month_diff)
  balance_avg <- ggplot2::ggplot(data = prep_frame_altered, aes(x = card_type, y = avg_balance, fill = card_type)) +
    ggplot2::geom_violin(width = violin_width) +
    ggplot2::geom_boxplot(width = 0.1, color = 'grey', alpha = 0.2) +
    viridis::scale_fill_viridis(discrete = TRUE) +
    hrbrthemes::theme_ipsum() +
    ggplot2::theme(legend.position = 'none', plot.title = element_text(size = 11)) +
    ggplot2::ggtitle(paste0('Avg Balance ', start_date, ' / ', ending_date)) +
    ggplot2::scale_y_continuous(labels = scales::comma)
  # balance_avg <- ggplot2::ggplot(data = prep_frame_altered, aes(x = avg_balance, group = card_type, fill = card_type)) +
  #   ggplot2::geom_density(adjust = adjust, alpha = alpha) +
  #   ggplot2::xlab('money') +
  #   ggplot2::ggtitle(paste0('Avg Balance ', start_date, ' / ', ending_date)) +
  #   hrbrthemes::theme_ipsum() +
  #   ggplot2::scale_x_continuous(labels = scales::comma)
  
  balance_change <- ggplot2::ggplot(data = prep_frame, aes(x = card_type, y = monthly_balance_delta, fill = card_type)) +
    ggplot2::geom_violin(width = violin_width) +
    ggplot2::geom_boxplot(width = 0.1, color = 'grey', alpha = 0.2) +
    viridis::scale_fill_viridis(discrete = TRUE) +
    hrbrthemes::theme_ipsum() +
    ggplot2::theme(legend.position = 'none', plot.title = element_text(size = 11)) +
    ggplot2::ggtitle(paste0('Avg Monthly Balance Change ', start_date, ' / ', ending_date)) +
    ggplot2::scale_y_continuous(labels = scales::comma)
  # balance_change <- ggplot2::ggplot(data = prep_frame, aes(x = monthly_balance_delta, group = card_type, fill = card_type)) +
  #   ggplot2::geom_density(adjust = adjust, alpha = alpha) +
  #   ggplot2::xlab('money') +
  #   ggplot2::ggtitle(paste0('Avg Monthly Balance Change ', start_date, ' / ', ending_date)) +
  #   hrbrthemes::theme_ipsum() +
  #   ggplot2::scale_x_continuous(labels = scales::comma)
  
  flow_VYDAJ <- ggplot2::ggplot(data = prep_frame, aes(x = card_type, y = monthly_VYDAJ, fill = card_type)) +
    ggplot2::geom_violin(width = violin_width) +
    ggplot2::geom_boxplot(width = 0.1, color = 'grey', alpha = 0.2) +
    viridis::scale_fill_viridis(discrete = TRUE) +
    hrbrthemes::theme_ipsum() +
    ggplot2::theme(legend.position = 'none', plot.title = element_text(size = 11)) +
    ggplot2::ggtitle(paste0('Avg Monthly Withdrawal ', start_date, ' / ', ending_date)) +
    ggplot2::scale_y_continuous(labels = scales::comma)
  # flow_VYDAJ <- ggplot2::ggplot(data = prep_frame, aes(x = monthly_VYDAJ, group = card_type, fill = card_type)) +
  #   ggplot2::geom_density(adjust = adjust, alpha = alpha) +
  #   ggplot2::xlab('money') +
  #   ggplot2::ggtitle(paste0('Avg Monthly Withdrawal ', start_date, ' / ', ending_date)) +
  #   hrbrthemes::theme_ipsum() +
  #   ggplot2::scale_x_continuous(labels = scales::comma)
  
  flow_PRIJEM <- ggplot2::ggplot(data = prep_frame, aes(x = card_type, y = monthly_PRIJEM, fill = card_type)) +
    ggplot2::geom_violin(width = violin_width) +
    ggplot2::geom_boxplot(width = 0.1, color = 'grey', alpha = 0.2) +
    viridis::scale_fill_viridis(discrete = TRUE) +
    hrbrthemes::theme_ipsum() +
    ggplot2::theme(legend.position = 'none', plot.title = element_text(size = 11)) +
    ggplot2::ggtitle(paste0('Avg Monthly Inflow ', start_date, ' / ', ending_date)) +
    ggplot2::scale_y_continuous(labels = scales::comma)
  # flow_PRIJEM <- ggplot2::ggplot(data = prep_frame, aes(x = monthly_PRIJEM, group = card_type, fill = card_type)) +
  #   ggplot2::geom_density(adjust = adjust, alpha = alpha) +
  #   ggplot2::xlab('money') +
  #   ggplot2::ggtitle(paste0('Avg Monthly Inflow ', start_date, ' / ', ending_date)) +
  #   hrbrthemes::theme_ipsum() +
  #   ggplot2::scale_x_continuous(labels = scales::comma)
  
  balance_total_summary <- tapply(prep_frame$balance, prep_frame$card_type, summary)
  balance_avg_summary <- tapply(prep_frame_altered$avg_balance, prep_frame_altered$card_type, summary)
  balance_change_summary <- tapply(prep_frame$monthly_balance_delta, prep_frame$card_type, summary)
  flow_VYDAJ_summary <- tapply(prep_frame$monthly_VYDAJ, prep_frame$card_type, summary)
  flow_PRIJEM_summary <- tapply(prep_frame$monthly_PRIJEM, prep_frame$card_type, summary)
  
  counts <- prep_frame %>%
    dplyr::group_by(card_type) %>%
    dplyr::count()
  
  #assign plots to .GlobalEnv
  assign(var_1, balance_total, envir = .GlobalEnv)
  assign(paste0(var_1, '_summary'), balance_total_summary, envir = .GlobalEnv)
  assign(var_2, balance_avg, envir = .GlobalEnv)
  assign(paste0(var_2, '_summary'), balance_avg_summary, envir = .GlobalEnv)
  assign(var_3, balance_change, envir = .GlobalEnv)
  assign(paste0(var_3, '_summary'), balance_change_summary, envir = .GlobalEnv)
  assign(var_4, flow_VYDAJ, envir = .GlobalEnv)
  assign(paste0(var_4, '_summary'), flow_VYDAJ_summary, envir = .GlobalEnv)
  assign(var_5, flow_PRIJEM, envir = .GlobalEnv)
  assign(paste0(var_5, '_summary'), flow_PRIJEM_summary, envir = .GlobalEnv)
  assign(stat_inf, counts, envir = .GlobalEnv)
}
plot_balance_cards_comp(trans_altered, account_altered, disp_altered, card_altered, beginning_date('1998'), ending_date('1998'), 'balance_total_1998', 'balance_avg_1998', 'balance_change_1998', 'flow_VYDAJ_1998', 'flow_PRIJEM_1998', 'counts_1998')
```

#### Results on `r counts_1998$n[1]` classic, `r counts_1998$n[2]` gold, `r counts_1998$n[3]` junior and `r counts_1998$n[4]` no_cards Customers from 1998

```{r echo = FALSE, warning = FALSE}
balance_total_1998
balance_total_1998_summary
```

```{r echo = FALSE, warning = FALSE}
balance_avg_1998
balance_avg_1998_summary
```

```{r echo = FALSE, warning = FALSE}
balance_change_1998
balance_change_1998_summary
```

```{r echo = FALSE, warning = FALSE}
flow_VYDAJ_1998
flow_VYDAJ_1998_summary
```

```{r echo = FALSE, warning = FALSE}
flow_PRIJEM_1998
flow_PRIJEM_1998_summary
```




#```{r child = '../footer.Rmd'}
#```