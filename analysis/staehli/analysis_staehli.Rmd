```{r child = '../header.Rmd'}
```

```{r,echo=FALSE}
library("RPostgreSQL")
library(tidyverse)
library("ggridges")
library(hrbrthemes)

source('../helpers/prepareData.R')

# define the database connection string
DB_HOST='server2053.cs.technik.fhnw.ch' # or 86.119.36.94 depending on the network
DB_PORT = 5432
DB_DBNAME = 'bank_db' # or 'warenkorb_db'
DB_USERNAME = 'db_user' 
DB_PASSWORD = 'db_user_pw' 

# load the PostgreSQL driver
drv <- dbDriver("PostgreSQL")
# connect to the database
con <- dbConnect(drv, dbname = DB_DBNAME,
                 host = DB_HOST, port = DB_PORT,
                 user = DB_USERNAME, password = DB_PASSWORD)
```

#### Tabelle orders (Stähli)
- Gewisse Zeilen enthalten kein «k_symbol»
  - Unsaubere Klassifizierung -> Zuweisung der Kategorie unbekannt
- Welche Einheit ist «amount»
  - Die Währung ist die Tschechische Krone
- Frequenz und Datum von Daueraufträge prüfen 

### Permanent Orders

```{sql connection=con, output.var = "permanent_orders", echo = FALSE}
SELECT trans.trans_id, trans.date, orders.orders_id, orders.account_id, orders.account_to, orders.amount,  
CASE 
	WHEN orders.k_symbol = 'SIPO' THEN 'household' 
	WHEN orders.k_symbol = 'LEASING' THEN 'leasing'
	WHEN orders.k_symbol = 'UVER' THEN 'loan payment'
	WHEN orders.k_symbol = 'POJISTNE' THEN 'insurrance payment'
	WHEN orders.k_symbol = ' ' THEN 'NA'
END
FROM orders
INNER JOIN trans ON orders.account_id = trans.account_id
WHERE orders.amount = trans.amount 
ORDER BY account_id, orders_id, date
```

#### Average time of permanent orders

```{r,echo=FALSE}

# LAG Function zum Differenz der Spalten ausrechnen
difference_in_time <- permanent_orders %>%
  group_by(orders_id) %>%
  mutate(dif_in_days = date - lag(date)) 
  
head(difference_in_time)
average_time_p_orders <- mean(difference_in_time$dif_in_days, na.rm = TRUE) #Calculation of average time (30d)

```
Calculation of the average time of permanent orders. result is `r average_time_p_orders`


#### Tabelle district (Stähli)
- Spalten sprechend benennen gemäss Beschreibung
- district id 69 hat bei A12 und A15 ein «null», bitte vervollständigen

```{sql connection=con, output.var = "district", echo = FALSE}

SELECT a1 as district_code, a2 as district_name,
a3 as region, a4 as no_of_inhabitants, a5 as municipalities_u499,
a6 as municipalties_500_1999, a7 as municipalties_2000_9999, a8 as municipalties_o9999,
a9 as no_of_cities, a10 as ratio_urban_inhabitants, a11 as avg_salary,
a12 as unemploymt_rate95, a13 as unemploymt_rate96, a14 as no_enterpreneurs_per_1000,
a15 as commited_crimes95, a16 as commited_crimes96 
from district

```

### Bearbeitung eigener Hypothesen

- Kunden, die einen Kredit haben, und den Status nicht bezahlt, sind schlechte Kunden.
  - Meiste Kunden hatten gar nie einen Kredit
  
Tasks:
  Loan status join mit Kartentyp
  Relativ zur Ausstellung zur Karte, welche Loans wurden getätigt?

```{sql connection=con, output.var = "accounts_loans", echo = FALSE}

SELECT account.account_id, account.district_id,
account.date AS date_account_creation, loan.loan_id,loan.date , loan.amount AS loan_amount, loan.duration,
loan.payments, 
CASE 
	WHEN loan.status = 'A' THEN 'finished, OK'
	WHEN loan.status = 'B' THEN 'finished, unpayed'
	WHEN loan.status = 'C' THEN 'running, OK'
	WHEN loan.status = 'D' THEN 'running, in debt'
END AS payment_status
FROM account 
LEFT JOIN loan ON account.account_id = loan.account_id
GROUP BY account.account_id, loan.loan_id
ORDER BY account.date
````


```{r,echo=FALSE}
head(accounts_loans)

#Most accounts didn't ever have loan
ggplot(accounts_loans, aes(x = payment_status)) + geom_bar(alpha = 3/4, position = "identity") + coord_flip()

#Check if null values not in loan table
accounts_loans %>%
  filter(account_id == 0 | district_id == 0 | date_account_creation == 0) %>%
  view() 

# filter dataframe not empty values and rename date column 
accounts_with_loans <- na.omit(accounts_loans) %>%
  rename(date_of_loan = date)

view(accounts_with_loans)

ggplot(accounts_with_loans, aes(x = payment_status)) + geom_bar() + coord_flip() 
  

ggplot(accounts_with_loans, aes(x = date_of_loan, y = loan_amount, color = payment_status)) + 
  geom_point(binwidth=15) + geom_smooth(method='lm',binwidth=15) +
  scale_x_date(date_breaks = "year", date_labels = "%Y") 
  
str(accounts_with_loans)

#calculate new row with count values for plotting
accounts_with_loans_count <- as.data.frame(transmute(accounts_with_loans, 
                                                     loan_amount, loan_id)) %>% arrange(loan_id)

str(accounts_with_loans_count)

colMeans(accounts_with_loans_count[1], na.rm = FALSE)

library(DescTools)

ggplot(accounts_with_loans,aes(x = date_of_loan)) +
  geom_histogram(binwidth=15, fill="#69b3a2", color="#e7ecef", alpha=0.9) +
  labs(title = "Amount of loans at time") +
  scale_x_date(date_breaks = "year", date_labels = "%Y")


```

## Untersuchung "Loans"
### "Loans" und Kartentypen

```{sql connection=con, output.var = "card_types_loans", echo = FALSE}
SELECT card.issued AS card_issued, card.type, account.account_id,
loan.loan_id, loan.date AS loan_date, loan.amount, loan.duration,
loan.payments, CASE 
	WHEN loan.status = 'A' THEN 'finished - no problems'
  	WHEN loan.status = 'B' THEN 'finished - unpayed'
  	WHEN loan.status = 'C' THEN 'running - OK'
  	WHEN loan.status = 'D' THEN 'running - in debt' 
	END AS loan_status
FROM disp
INNER JOIN card ON card.disp_id = disp.disp_id
INNER JOIN account ON disp.account_id = account.account_id
INNER JOIN loan ON account.account_id = loan.account_id
ORDER BY account.account_id
```

```{r,echo=FALSE}
# Packages
require(scales)

#Aesthtetics
color_fill  <- scale_fill_brewer(palette = "Pastel1")
scales_comma <- scale_x_continuous(labels = comma)

# Wie viele Loans sind bestehend für jeden Kartenbenutzer
ggplot(card_types_loans, aes(x = type, fill = loan_status)) + geom_bar(alpha = 0.8) + color_fill

# Welche Accounts hatten vor Ausstellung einer Karte bereits einen Loan und wie sah es bez. Kartentyp aus
# Remark zu plot:  Tag 0 entspricht Ausstellung der Karte
card_types_loans_timediff <- card_types_loans %>%
  filter(loan_date < card_issued) %>%
  mutate(time_diff_loan_card = abs(difftime(loan_date, card_issued))) %>% glimpse()

# Welche Accounts hatten vor Ausstellung einer Karte bereits einen Loan und wie sah es bez. Kartentyp aus
# Remark zu plot:  Tag 0 entspricht Ausstellung der Karte   
ggplot(card_types_loans_timediff, aes(time_diff_loan_card, fill = type)) + geom_density(alpha = 0.8) + color_fill +
  labs(title = "Date from loan to card")  

# Wie sehen die Loan AMounts zu den einzelnen Kartentypen aus?
card_types_loans %>%
  ggplot(aes(x = amount, fill = type)) + geom_density(alpha = 0.5) + color_fill + 
  labs( title = "Loan amount on card type") + scale_x_continuous(labels = comma)

# Monatliche Zahlungen nach Kartentype
card_types_loans %>%
  ggplot(aes(x = payments, fill = type)) + geom_density(alpha = 0.5) + color_fill + 
  labs( title = "Monthly Payments on card_type") + scale_x_continuous(labels = comma)

# Wie sieht das Kreditvolumen im Bezug auf die Dauer aus?
card_types_loans %>%
  ggplot(aes(x = duration, y = amount, fill = type)) + 
  geom_col(position = "dodge") + 
  scale_y_continuous(labels = comma) + scale_x_continuous(breaks = card_types_loans$duration) + color_fill

```



### "Loans" und weitere Demografische Daten

```{sql connection=con, output.var = "loans_demographic", echo = FALSE}
 SELECT 
	CASE WHEN MOD(birth_number / 100, 100) > 50 THEN 
		'f'
	ELSE
		'm'
	END as gender,
	CASE WHEN MOD(birth_number / 100, 100) > 50 THEN
		TO_DATE(CONCAT('19', CAST(birth_number-5000 AS VARCHAR(6))), 'YYYYMMDD')
	ELSE
		TO_DATE(CONCAT('19', CAST(birth_number AS VARCHAR(6))), 'YYYYMMDD')
	END as birthdate,
	EXTRACT(YEAR FROM AGE('1998-12-31', CASE WHEN MOD(birth_number / 100, 100) > 50 THEN TO_DATE(CONCAT('19', CAST(birth_number-5000 AS VARCHAR(6))), 'YYYYMMDD') ELSE TO_DATE(CONCAT('19', CAST(birth_number AS VARCHAR(6))), 'YYYYMMDD') END)) as age,
	card.type AS card_type, card.issued AS card_issued, loan.loan_id, loan.account_id,
	loan.date AS loan_granted, loan.amount AS loan_amount, loan.duration AS loan_duration, CASE
	WHEN loan.status = 'A' THEN 'finished - no problems'
  	WHEN loan.status = 'B' THEN 'finished - unpayed'
  	WHEN loan.status = 'C' THEN 'running - OK'
  	WHEN loan.status = 'D' THEN 'running - in debt' 
	END AS loan_status, loan.payments AS loan_payments
FROM client
INNER JOIN disp ON client.client_id = disp.client_id
INNER JOIN card ON disp.disp_id = card.disp_id
INNER JOIN account ON disp.account_id = account.account_id
INNER JOIN loan ON account.account_id = loan.account_id
ORDER BY loan.loan_id
 
````

```{r,echo=FALSE}
library(ggridges)
glimpse(loans_demographic)

#Verteilung des Geschlechts 
#Gleiche Anzahl Loans für Mann und Frau (Kartentypen sehen ebenfalls identisch aus)
loans_demographic %>%
ggplot(aes(x = gender, fill = card_type)) +
  geom_bar(alpha = 3/4) +
  scale_fill_brewer(palette = "Set2") +
  labs(title = "Anz. M/F, welche einen Loan haben")

#Verteilung des Alters im Bezug auf Loans und Payment_status
summary(loans_demographic[3])
loans_demographic %>%
  ggplot(aes(x = age, fill = loan_status)) + 
  geom_density(alpha = 1/3, position = "stack") +
  labs(title = "Altersverteilung und Loanstatus")

```

```{r,echo=FALSE}
#Âesthetic Mappings
library(fmsb)
color_fill<- scale_fill_brewer(palette = "Set2")

all_clients <- get_all_clients()
head(all_clients)

#Verteilung des Alters und Geschlechts
all_clients %>%
  ggplot(aes(x = age, fill = gender)) + 
  color_fill +
  geom_density(alpha = 1/3)

#Verteilung des Geschlechts nach Wohndistrikte und nach Kartentypen

all_clients_join_region_ctype <- get_all_clients_join_region_ctype()
view(all_clients_join_region_ctype)

# MEnge aller Kunden zugeordnet zu den Distrikten
all_clients_join_region_ctype %>%
  ggplot(aes(x = region, fill = type)) +
  geom_bar(alpha = 1/2, position = "stack") + 
  labs(title = "Amount of Customers in Regions") +
  coord_flip() 

# Altersveteilung nach Kartentyp
plot_all_types_age <- function(type_card){
  all_clients_join_region_ctype %>%
    filter(type == type_card) %>%
    ggplot(aes(x = age, fill = type)) +
    geom_density(alpha = 1/2, fill = "lightblue") + 
    labs(title = "Alterverteilung Karte",type_card)
}
plot_all_types_age("junior")
plot_all_types_age("gold")
plot_all_types_age("classic")

summary(all_clients_join_region_ctype$age)

#Alterverteilung in den Distrikten
ggplot(all_clients_join_region_ctype, aes(x = age, fill = region)) +
  geom_density(alpha = 1/2) + 
  facet_wrap(~region, ncol= 2) + 
  color_fill +
  scale_x_continuous(breaks = seq(0,90,15))

ggplot(all_clients_join_region_ctype, aes(x = age, y = region, fill = region)) +
  geom_density_ridges(alpha = 1/2) + 
  scale_fill_brewer(palette = "YlOrRd") +
  scale_x_continuous(breaks = seq(0,90,10))

```


## Untersuchung "Districts"
### Können Kartennutzer nach der Kartenklassifizierung einem District zugeordnet werden?
Beobachtungen:
Generell:
- D50 Anteile ausgeglichen
- Verhältnisse District 25/29 passen nicht ins Muster

Classic:
- Anteil verhältnismässig hoch: D31
- tief: D25, D56
- Fast überall am meisten vorhanden
- District 25 fällt sogar unter Goldanteil und Junior Anteil
- D32-36 starker seitwärtstrend

Gold:
- Anteil verhältnismässig hoch: 76, D69
- Tief: D54, D68, 
- Anteile meist gering
- District 29(höher als Classic), 69 auffällig hoch 

Junior:
- Anteil verhältnismässig hoch: D9, D2, D18, D59(höher als Classic), D69
- Tief: D54, D68

```{sql connection=con, output.var = "client_card_districts", echo = FALSE}

SELECT card.type AS card_type, disp.client_id, client.district_id,
district.a2 AS district_name, district.a11 AS district_salary, district.a4 AS no_inhabitants FROM card
FULL JOIN disp ON card.disp_id = disp.disp_id
FULL JOIN client ON disp.client_id = client.client_id
FULL JOIN district ON client.district_id = district.a1
ORDER BY card.type, disp.client_id


````

```{r,echo=FALSE}

#Amount of cards in district 
ggplot(client_card_districts, aes(x = district_id, color = card_type)) +
  geom_freqpoly(binwidth = 1, alpha = 3/4) + labs(title = "Amount of all customers in districts" ) +
  scale_x_continuous(breaks = 1:77) + coord_cartesian(xlim = 1:77, ylim = 1:100)  #Richtig skalieren!!
 

#Anzahl Karten runtergebrochen auf einen Kartennutzer
card_district_one_usr <- client_card_districts %>%
  select(district_id, card_type, no_inhabitants) %>%
  group_by(district_id, card_type, no_inhabitants) %>%
  summarise(number_of_cards = n()) %>% 
  mutate(no_cards_per_inhabitant = round((number_of_cards / no_inhabitants)*1000, 3)) %>% 
  filter(card_type != FALSE) #unbekannte Zellenwerte card_type nicht miteinbez. #%>% view()

#Plot Karten aller User im Bezug auf einen Distrikt
ggplot(card_district_one_usr, aes(x = district_id, y = no_cards_per_inhabitant, color = card_type)) +
  geom_line(alpha = 3/4) + scale_x_continuous(breaks= 1:77)+ 
  labs(title = "Card_types per head") + xlab(label = "districts") + 
  coord_cartesian(xlim = 1:77, ylim = range(0,0.25,0.1)) #zoom in 
         

```


KOnten mit einem hohen Kontostand sind gute Kunden.
  - Erhebe Daten aus Transaktion passend zu deren Account_id bezüglich ihrer Balance

Beobachtung:

  - Steigender Trend bez. Transaktionstyp Bargeldbezug (withdrawal in cash) 
    -> Die Nachfrage nach KK sollte da sein 
    -> Welche Kunden haben Bargeldbezüge getätigt? Nur Kunden mit bestehender KK? Falls nein, mögliche Kunden für Verkauf einer KK
    
Tasks:
  Welche Kartentypen tätigen welche Transaktionen
  
```{sql connection=con, output.var = "disp_transactions", echo = FALSE}

SELECT disp.disp_id, disp.client_id, disp.account_id, disp.type, trans.trans_id, trans.date,
CASE
	WHEN trans.type = 'PRIJEM' THEN 'credit'
	WHEN trans.type = 'VYDAJ' THEN 	'withdrawal'
END AS transaction_type,
CASE 
	WHEN trans.operation = 'VYBER KARTOU' THEN 'credit card withdrawal'
	WHEN trans.operation = 'VKLAD' THEN 'credit in cash'
	WHEN trans.operation = 'PREVOD Z UCTU' THEN 'collection of other bank'
	WHEN trans.operation = 'VYBER' THEN 'withdrawal in cash'
	WHEN trans.operation = 'PREVOD NA UCET' THEN 'remittance to another bank' 
END AS transaction_operation,
trans.amount, ROUND(trans.balance) AS balance_after_trans
FROM disp 
LEFT JOIN trans ON disp.account_id = trans.account_id
ORDER BY trans.trans_id

```` 
  
```{r,echo=FALSE}

head(disp_transactions)

disp_transactions <- disp_transactions %>% #convert dataframe to a tibble
  as_tibble(disp_transactions)

#Alle Transaktinen pro Jahr (Alle Inhabertypen)
trans_per_year <- disp_transactions %>%
  separate(date, sep = "-", into = c("year", "month", "day") ) %>%
  transmute(trans_id, type, year, transaction_type, transaction_operation)


# Bargeldbezüge von Disponenten
trans_per_year_disponent <- disp_transactions %>%
  separate(date, sep = "-", into = c("year", "month", "day") ) %>%
  transmute(trans_id,type , year, transaction_type, transaction_operation) %>%
  filter(type == "DISPONENT") %>% arrange(year)

head(trans_per_year_disponent)

ggplot(trans_per_year_disponent, aes(x = year, fill = transaction_operation)) +
  geom_bar(alpha = 3/4, position = "dodge") + scale_fill_brewer(palette = "Set3") +
  labs(title = "Amount of transactions of all disponents") + ylab("transactions")



```


Wann kommt eine Karte für einen Kunden infrage?
  - Viele Transaktionen oder Bargeldbezüge (withdrawals)
  - Kunden, ohne Karte, welche vermehrt Bezüge tätigen sollten eine Karte besitzen.

Wie alt sind Junior-Kartennutzer? Wo ist die Altersgrenze?
  Ältester User ist 24 Jahre alt.

Profil eines guten Kunden: Viele Transaktionen mit hohen Beträgen, zahlt seine Kredite stets zurück, macht häufig Gebrauch von der Kreditkarte

- Kunden, die ein Haus haben, haben mehr Geld.
  - Suche nach Accounts mit Transkationen für Haushalt und nach deren Balance


### Untersuchung der bezogenen Dienstleistungen pro Account 
Es werden nur Accounts untersucht, welche eine Karte haben.
Zeitfenster card issued 1998 und restliche Accounts

#### Validation via SQL:
Validation Loans: Loans in Transaktionen 652 obs. / Loans gesamt 682 obs.
Es git kein Servicekonstrukt mit nur Loan 



```{r,echo=FALSE}
check_services <- as_tibble(get_check_services())
glimpse(check_services)

## Alle DL bezogen im Jahr 1998 von allen Leuten die eine Karte haben
#Stimmt nicht mit anzahl orders überein wenn SQL abfrage gemacht/gGrund: Nur Personen mit Karte von 1998
comparisson_services <- check_services %>%
  transmute(account_id, card_YesNo = if_else(is.na(card_id) == FALSE, 1, 0 ),
            loan_YesNo = if_else(is.na(loan_id) == FALSE, 1, 0),
            order_YesNo = if_else(is.na(orders_id) == FALSE, 1, 0)) %>%
  distinct(account_id, card_YesNo, loan_YesNo, order_YesNo ) %>% 
  unite(card_loan_order, c("card_YesNo","loan_YesNo", "order_YesNo"), sep = "" ) %>%
  arrange(account_id) %>%
  mutate(number_obs = dplyr::row_number(account_id)) %>%
  print()

# Alle DL bezogen von Kartennutzer im Jahr 1998 und allen Nutzern, die keine Karte haben über alle Jahre
comparisson_services %>%
  ggplot(aes(card_loan_order)) +
  geom_bar(fill = "lightblue", color = "black", position = "identity") +
  scale_x_discrete(labels = c("None", "order", "loan/order", "card", "card/order", "card/loan/order"))+
  geom_text(stat = "count", aes(label = ..count.., vjust = -0.5)) +
  labs( title = "Number of Counts for each Service Construct",subtitle = "no customer counted twice!")
 
## Verteilung der DL's über die Account_ID's
comparisson_services %>%
  ggplot(aes(x = account_id, fill = card_loan_order)) +
  geom_histogram(binwidth = 50, position = "identity") + 
  scale_fill_brewer(palette = "Set2") +
  scale_x_continuous(breaks = seq(0,11000,2000)) +
  labs(title = "Histogram over Account_ID's regarding to Services", 
       caption = "3-Digit Code: 1xx = card / x1x = loan / xx1 = order") +
  facet_wrap(~card_loan_order, ncol = 2)

ggplot(comparisson_services, aes(x = number_obs , fill = card_loan_order)) +
  geom_histogram(position = "identity", binwidth = 30) +
  facet_wrap(~card_loan_order, ncol = 2) +
  scale_fill_brewer(palette = "Set2") + 
  labs(title = "Distirbution of obs. on RowIndex", 
       caption = "3-Digit Code: 1xx = card / x1x = loan / xx1 = order")

```

